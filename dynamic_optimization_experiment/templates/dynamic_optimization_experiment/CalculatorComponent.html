{% load otree %}

<div class="card bg-light m-3">
  <div class="card-body">
    <h2 style="text-align: center;">
        Budgeting Calculator
    </h2>
    <br/>

    <style>
      table,
      td {
          border: 1px solid #333;
      }
      
      thead,
      tfoot {
          background-color: #333;
          color: #fff;
      }
    </style>

    <!-- no way this is best practice -->
    <div id="" style="display: none;">
      <div id="constants_income">
        {{Constants.income}}
      </div>
      <div id="constants_price_per_unit">
        {{Constants.price_per_unit}}
      </div>
      <div id="constants_interest_rate">
        {{Constants.interest_rate}}
      </div>
      <div id="constants_num_rounds">
        {{Constants.num_rounds}}
      </div>
      <div id="constants_k_payoff">
        {{Constants.k_payoff}}
      </div>
    </div>

    <table id="myTable" style="text-align: center;">
      <tbody id="table_body">
        <tr style="background-color:chartreuse;">
          <td>Period</td>
          <td>Income (Tokens)</td>
          <td>Price per Unit</td>
          <td>Interest Rate (%)</td>
          <td>Token Balance (beginning of the period)</td>
          <td>Purchased Units</td>
          <td>Points</td>
          <td>Total Points</td>
          <td>Final Tokens Balance</td>
        </tr>
      </tbody>
    </table>

    <br/>
    <div style="text-align: center;">
      <button onClick=resetEachRowFromCurrPeriodOnward(event)>Reset values</button>
      <button style="background-color: red;"onClick=calcHypotheticalRow(event)>Calculate</button>
    </div>

    <script>
      // let obj =  getAllGameConstants()

      // function getAllGameConstants(){

      // }

    </script>

    <script>
      //fetch constants
      let constantsNumberOfRounds = Number(document.getElementById("constants_num_rounds").innerHTML.trim());
      let constantsKPayoff = Number(document.getElementById("constants_k_payoff").innerHTML.trim());

      let constantsIncome = Number(document.getElementById("constants_income").innerHTML.trim());
      let constantsPricePerUnit = Number(document.getElementById("constants_price_per_unit").innerHTML.trim());
      let constantsInterestRate = Number(document.getElementById("constants_interest_rate").innerHTML.trim());
      
      // let currentStartingTokenBalance = 1000;
      // let currentStartingTokenBalance = Number(document.getElementById(`total-final-balance-${js_vars.player_round_number}`).innerHTML.trim());

      //create appendable elements which'll later be cloned
      let incomeTableDataElem = document.createElement('td');
      let pricePerUnitTableDataElem = document.createElement('td');
      let interestRateTableDataElem = document.createElement('td');

      //write constants to first clones
      incomeTableDataElem.innerHTML = constantsIncome;
      pricePerUnitTableDataElem.innerHTML = constantsPricePerUnit;
      interestRateTableDataElem.innerHTML = constantsInterestRate;

      // console.log('constantsIncome',constantsIncome);
      // console.log('typeof constantsIncome',typeof constantsIncome);
      // console.log(constantsPricePerUnit);
      // console.log(constantsInterestRate);
      // console.log(constantsNumberOfRounds);
      // console.log(constantsKPayoff);

      //here is the function used to calculate points gained from units of output
      function calcPointGain(output,kPayoffConstant){
        return (kPayoffConstant*(output**2))+5 
      }

      function initiateTableUpdate(period){
        //fetch table, make new row to be appended. add styling.
        let budgetingCalculatorTable = document.getElementById('myTable');

        async function setUpPastRows(period,table){
          // console.log('setUpPastRows invoked');
          // console.log('period',period);
          // console.log('table',table);
          // console.log('js_vars',js_vars);
          // console.log('js_vars.purchased_units_across_all_rounds',js_vars.purchased_units_across_all_rounds);

          //for each period which has passed
          for ( let i = 1; i < period; i++ ) {
            let passedRow = document.createElement('tr');
            passedRow.id = `row-period-${i}`;
            passedRow.style.cssText = 'background-color:white';

            let passedPeriodTableDataElem = document.createElement('td');
            passedPeriodTableDataElem.innerHTML = `${i}`;

            //create tds for period, income, price per unit, interest rate,
            let incomeClone = incomeTableDataElem.cloneNode(true);
            let pricePerUnitClone = pricePerUnitTableDataElem.cloneNode(true);
            let interestRateClone = interestRateTableDataElem.cloneNode(true);
            //create tds for token balance, purchased units, points, total points, and final token balance
            
            //if first period, previus final tokens balance is zero
            let previousFinalTokensBalance = ( i === 1 ) ? 0 : Number(document.getElementById(`final-token-balance-${i-1}`).innerHTML);
            let interestToBeAdded = ( i === 1 ) ? 0 : previousFinalTokensBalance*constantsInterestRate*.01;
            //if first period, passed starting token balance equals income. else equals previousFinalTokensBalance + interest + income
            let passedStartingTokenBalance = ( i === 1 ) ? constantsIncome : constantsIncome+previousFinalTokensBalance+interestToBeAdded;
            //create passed start token balance element. write to element.
            let passedStartingTokenBalanceTableDataElem = document.createElement('td')
            passedStartingTokenBalanceTableDataElem.id = `starting-token-balance-${i}`;
            passedStartingTokenBalanceTableDataElem.innerHTML = passedStartingTokenBalance;
            
            let passedPurchasedUnits = js_vars.purchased_units_across_all_rounds[i-1]; 

            //create passed purchased units element.  write to element.
            let passedPurchasedUnitsTableDataElem = document.createElement('td');
            passedPurchasedUnitsTableDataElem.id = `purchased-unit-input-${i}`;
            passedPurchasedUnitsTableDataElem.innerHTML = passedPurchasedUnits;
            
            //calculate points.  create element.
            let passedPointsGained = calcPointGain(passedPurchasedUnits,constantsKPayoff);
            passedPointsGainedTableDataElem = document.createElement('td');
            passedPointsGainedTableDataElem.id = `points-data-${i}`;
            passedPointsGainedTableDataElem.innerHTML = passedPointsGained;
            
            //calculate total points.  create element.
            //if first period, most recent point total is zero. else fetch most recent total points
            // let mostRecentPointTotal = ( i === 1 ) ? 0 : Number(String((document.getElementById(`total-points-${i-1}`).innerHTML)).toFixed(2))
            let mostRecentPointTotalStr = ( i === 1 ) ? 0 : (Number(document.getElementById(`total-points-${i-1}`).innerHTML)).toFixed(2)
            let mostRecentPointTotalNum = Number(mostRecentPointTotalStr);
            let currentPointTotal = ( i === 1 ) ? passedPointsGained : (passedPointsGained+mostRecentPointTotalNum);
            
            let currentPointTotalTableDataElem = document.createElement('td');
            currentPointTotalTableDataElem.id = `total-points-${i}`;
            currentPointTotalTableDataElem.innerHTML = currentPointTotal.toFixed(2);

            //calculate final token balance
            let costOfPurchase = passedPurchasedUnits * constantsPricePerUnit
            let finalTokenBalance = passedStartingTokenBalance - costOfPurchase; 

            let finalTokenBalanceTableDataElem = document.createElement('td');
            finalTokenBalanceTableDataElem.id = `final-token-balance-${i}`;
            finalTokenBalanceTableDataElem.innerHTML = finalTokenBalance;

            // console.log('previousFinalTokensBalance',previousFinalTokensBalance)
            // console.log('interestToBeAdded',interestToBeAdded)
            // console.log('passedStartingTokenBalance',passedStartingTokenBalance)
            // console.log('passedPurchasedUnits>>>>',passedPurchasedUnits)
            // console.log('passedPointsGained>>>>',passedPointsGained)
            // console.log('mostRecentPointTotalStr>>>>',mostRecentPointTotalStr)
            // console.log('mostRecentPointTotalNum>>>>',mostRecentPointTotalNum)
            // console.log('currentPointTotal>>>>',currentPointTotal)
            // console.log('finalTokenBalance>>>>',finalTokenBalance)

            //then append all created elements
            passedRow.appendChild(passedPeriodTableDataElem);
            passedRow.appendChild(incomeClone);
            passedRow.appendChild(pricePerUnitClone);
            passedRow.appendChild(interestRateClone);
            passedRow.appendChild(passedStartingTokenBalanceTableDataElem);
            passedRow.appendChild(passedPurchasedUnitsTableDataElem);
            passedRow.appendChild(passedPointsGainedTableDataElem);
            passedRow.appendChild(currentPointTotalTableDataElem);
            passedRow.appendChild(finalTokenBalanceTableDataElem);

            table.appendChild(passedRow);
          }

          return [period,table]
        }

        async function setUpCurrentRow(period,table){
          console.log('setUpCurrentRow period',period)
          console.log('setUpCurrentRow table',table)
          let currRow = document.createElement('tr');
          currRow.style.cssText  = "background-color:yellow";
          currRow.id = `row-period-${js_vars.player_round_number}`;

          //creating table elements to append
          let periodTableDataElem =  document.createElement('td');
          periodTableDataElem.innerHTML = period;
          
          //cloning the constants
          let incomeClone = incomeTableDataElem.cloneNode(true);
          let pricePerUnitClone = pricePerUnitTableDataElem.cloneNode(true);
          let interestRateClone = interestRateTableDataElem.cloneNode(true);

          let mostRecentFinalTokenBalance = (period === 1) ? 0 : Number(document.getElementById(`final-token-balance-${period-1}`).innerHTML)
          //if first period, no interest.
          let interestToBeAdded = (period  === 1) ? 0 : mostRecentFinalTokenBalance*constantsInterestRate*.01;
          //if first period, current starting token balance equals income.
          let currentStartingTokenBalance = (period === 1) ? constantsIncome : mostRecentFinalTokenBalance+constantsIncome+interestToBeAdded;
          
          let tokenBalanceTableDataElem = document.createElement('td');
          tokenBalanceTableDataElem.id = `starting-token-balance-${period}`
          //if first period, no interest.  otherwise calculate interest
          tokenBalanceTableDataElem.innerHTML = currentStartingTokenBalance.toFixed(2);

          //adding input for purchased units
          let purchasedUnitsInputForTable = document.createElement('input');
          purchasedUnitsInputForTable.type = "number";
          purchasedUnitsInputForTable.min = 0;
          purchasedUnitsInputForTable.id = `purchased-unit-input-${period}`;
          purchasedUnitsInputForTable.style.cssText = "background-color:#ffbbff;text-align:center";

          //appending all children to the row
          currRow.appendChild(periodTableDataElem);
          currRow.appendChild(incomeClone);
          currRow.appendChild(pricePerUnitClone);
          currRow.appendChild(interestRateClone);
          currRow.appendChild(tokenBalanceTableDataElem);
          currRow.appendChild(purchasedUnitsInputForTable);

          //creating first set of empty elements to input
          let currPointsTableDataElem = document.createElement('td');
          currPointsTableDataElem.id = `points-data-${period}`
          currPointsTableDataElem.innerHTML = 0
          
          //if first period, most recent point total is zero.
          let mostRecentPointTotal = (period === 1) ? 0 : Number(document.getElementById(`total-points-${period-1}`).innerHTML);

          let totalPointsTableDataElem = document.createElement('td');
          totalPointsTableDataElem.id = `total-points-${period}`
          totalPointsTableDataElem.innerHTML = mostRecentPointTotal;

          let finalTokenBalanceTableDataElem = document.createElement('td');
          finalTokenBalanceTableDataElem.id = `final-token-balance-${period}`;
          finalTokenBalanceTableDataElem.innerHTML = currentStartingTokenBalance.toFixed(2);

          currRow.append(currPointsTableDataElem);
          currRow.append(totalPointsTableDataElem);
          currRow.append(finalTokenBalanceTableDataElem);

          //appending row to table
          table.appendChild(currRow)

          return [period,table];
        }

        return setUpPastRows(period,budgetingCalculatorTable)
          .then((arr)=>{
            return setUpCurrentRow(arr[0],arr[1]);
          })
          .then((arr)=>{
            for ( let i = period+1; i < constantsNumberOfRounds+1; i++ ) {
              populateThenAppendFutureRows(i,arr[1]);
            }
            return console.log('table !');
          })
          .catch((err)=>{
            return console.error(`err with populating future rows.  this is your err: ${err}`)            
          })
      }

      function populateThenAppendFutureRows(futurePeriod,table){
        //if this is the first round
        let lastFinalTokenBalance = (futurePeriod === 2 ) ? constantsIncome : Number(document.getElementById(`final-token-balance-${futurePeriod-1}`).innerHTML);
        let futureRow = document.createElement('tr');
        futureRow.id = `row-period-${futurePeriod}`
        futureRow.style.cssText = 'background-color:#DCDCDC';

        let futurePeriodTableDataElem =  document.createElement('td');
        futurePeriodTableDataElem.innerHTML = futurePeriod;
        //create the clones to append constants
        let incomeClone = incomeTableDataElem.cloneNode(true);
        let pricePerUnitClone = pricePerUnitTableDataElem.cloneNode(true);
        let interestRateClone = interestRateTableDataElem.cloneNode(true);
        
        //find the last final token balance.  
        let mostRecentFinalTokenBalance = Number(document.getElementById(`final-token-balance-${futurePeriod-1}`).innerHTML);
        let interestToBeAdded = mostRecentFinalTokenBalance*constantsInterestRate*.01;
        //calculate current period's starting tokenbalance.
        let futureStartingTokenBalance = constantsIncome+mostRecentFinalTokenBalance+interestToBeAdded
        let futureStartingTokenBalanceTableDataElem = document.createElement('td');
        futureStartingTokenBalanceTableDataElem.id = `starting-token-balance-${futurePeriod}`;
        futureStartingTokenBalanceTableDataElem.innerHTML = Number(futureStartingTokenBalance.toFixed(2));
        
        //create input element
        let futurepurchasedUnitsInputForTable = document.createElement('input');
        futurepurchasedUnitsInputForTable.type = "number";
        futurepurchasedUnitsInputForTable.min = 0;
        futurepurchasedUnitsInputForTable.id = `purchased-unit-input-${futurePeriod}`;
        futurepurchasedUnitsInputForTable.style.cssText = "background-color:#ffbbff;text-align:center";
        
        //create points, total points, and final tokens balance elements
        let futurePointsTableDataElem = document.createElement('td');
        futurePointsTableDataElem.id = `points-data-${futurePeriod}`;
        futurePointsTableDataElem.innerHTML = 0;
        
        let futureTotalPointsTableDataElem = document.createElement('td');
        futureTotalPointsTableDataElem.id = `total-points-${futurePeriod}`;
        futureTotalPointsTableDataElem.innerHTML = 0;

        let thisRoundsFinalTokenBalanceTableDataElem = document.createElement('td');
        thisRoundsFinalTokenBalanceTableDataElem.id = `final-token-balance-${futurePeriod}`
        thisRoundsFinalTokenBalanceTableDataElem.innerHTML = futureStartingTokenBalance.toFixed(2);

        futureRow.appendChild(futurePeriodTableDataElem);
        futureRow.appendChild(incomeClone);
        futureRow.appendChild(pricePerUnitClone);
        futureRow.appendChild(interestRateClone);
        futureRow.appendChild(futureStartingTokenBalanceTableDataElem);
        futureRow.appendChild(futurepurchasedUnitsInputForTable);
        futureRow.appendChild(futurePointsTableDataElem);
        futureRow.appendChild(futureTotalPointsTableDataElem);
        futureRow.appendChild(thisRoundsFinalTokenBalanceTableDataElem);
        
        table.appendChild(futureRow);
      }

      initiateTableUpdate(js_vars.player_round_number);

    </script>

    <!-- button functions -->
    <script>
      //resets values in the row (technically as a side effect)
      function resetEachRowFromCurrPeriodOnward(event){
        event.preventDefault();

        let currRow = document.getElementById(`row-period-${js_vars.player_round_number}`);

        for ( let i = js_vars.player_round_number; i <= constantsNumberOfRounds;  i++ ) {
          //if first period, last round's final token balance is equal to income. else fetch last round's token balance.          
          let lastRoundsFinalTokenBalance = (i === 1 ) ? constantsIncome : Number(document.getElementById(`final-token-balance-${i-1}`).innerHTML)
          //if first period, interest is equal to zero. else calculate interest based on last round's final token balance.
          let interestToBeAdded = ( i === 1 ) ? 0 : lastRoundsFinalTokenBalance*constantsInterestRate*.01;
          //since we're resetting values, the purchased units argument for calcPointGain is equal to 0.
          let pointsScoredThisRound = calcPointGain(0,constantsKPayoff);
          //if first period, current token balance iss equal to income. else
          let currTokenBalance = ( i === 1 ) ? constantsIncome : lastRoundsFinalTokenBalance+interestToBeAdded+constantsIncome;
          //if the first period, then total points is zero
          let lastRoundsPointTotal = (i === 1) ? 0 : Number(document.getElementById(`total-points-${i-1}`).innerHTML)
        
          updateFutureRowByPeriod(i,currTokenBalance,pointsScoredThisRound,lastRoundsPointTotal+pointsScoredThisRound,currTokenBalance);
          //here you could reset the values in the inputs -- if desired
        }
        console.log('reset calculator values!')
      }

      //once a player's final token balance is below zero,
      //under certain conditions users should not be allowed to proceed
      //example --> the "no-ponzi scheme rule" which essentially means a player may not end the game with a negative balance.
      //(I believe there are other rules too)
      function checkDebtLimit(periodNumber,income,finalTokenBalance){
        console.log('players final token balance is below zero!');
        console.log('check players debt limit!');
      }

      //calculate what values should be inputted
      //then call separate function to append those values
      function calcHypotheticalRow(event){
        event.preventDefault();

        //if first round, beginning token balance is income
        let beginningTokenBalance =(js_vars.player_round_number === 1) ? 1000 :  Number(document.getElementById(`token-balance-${js_vars.player_round_number}`).innerHTML);
        //if first round, beginning total points is 
        let beginningTotalPoints = (js_vars.player_round_number === 1) ? 0 : Number(document.getElementById(`total-points-${js_vars.player_round_number-1}`).innerHTML);
        
        let purchasedUnitInput = Number(document.getElementById(`purchased-unit-input-${js_vars.player_round_number}`).value);
        let hypotheticalPointGain = calcPointGain(purchasedUnitInput,Number(constantsKPayoff))
        let hypotheticalFinalTokenBalance = beginningTokenBalance - (purchasedUnitInput*constantsPricePerUnit)
        
        //not just here in calclHypotheticalRow -- also in the main update function
        //maybe here too
        // if ( hypotheticalFinalTokenBalance < 0 ) {
        //   checkDebtLimit(js_vars.player_round_number,constantsIncome,hypotheticalFinalTokenBalance)
        // }

        return updateCurrentRow(hypotheticalPointGain,
                                  beginningTotalPoints+hypotheticalPointGain,
                                  hypotheticalFinalTokenBalance)
          .then((startUpdatingAtThisRow)=>{
            // for ( let i = startUpdatingAtThisRow; i <= 4; i++ ) {
            for ( let i = startUpdatingAtThisRow; i <= Number(constantsNumberOfRounds); i++ ) {
              calculateValuesForRowUpdate(i);
            }

            return 'everything worked';

          }).catch((err)=>{
            return console.error(`this  is your err: ${err}`);
          });
      }

      //calculates then returns values required for a row update.  This is for the "calculate" button.
      //returns points, total points, and final tokens balance.
      async function calculateValuesForRowUpdate(periodNumber){
        let currRow = document.getElementById(`row-period-${periodNumber}`);
        
        let mostRecentFinalTokenBalance = Number(document.getElementById(`final-token-balance-${periodNumber-1}`).innerHTML)
        let interestToBeAdded = mostRecentFinalTokenBalance*constantsInterestRate*.01
        
        let futureStartingTokenBalance = Number((constantsIncome+mostRecentFinalTokenBalance+interestToBeAdded).toFixed(2));
        let futurePurchasedUnits = Number(document.getElementById(`purchased-unit-input-${periodNumber}`).value);
        let futurePointsScored = Number((calcPointGain(futurePurchasedUnits,constantsKPayoff)).toFixed(2));
        let futurePointsTotal = Number(document.getElementById(`total-points-${periodNumber-1}`).innerHTML)+futurePointsScored;
        let mostRecentPointTotal = Number(document.getElementById(`total-points-${periodNumber-1}`).innerHTML);
        let hypotheticalCostOfUnitsPurchased = constantsPricePerUnit*futurePurchasedUnits;
        let futureFinalTokenBalance = futureStartingTokenBalance-hypotheticalCostOfUnitsPurchased;

        //not just here in calculateValuesFoorRowUpdate -- also in the main update function
        if ( futureFinalTokenBalance < 0 ) {
          checkDebtLimit(js_vars.player_round_number,constantsIncome,futureFinalTokenBalance)
        }

        return updateFutureRowByPeriod(periodNumber,futureStartingTokenBalance,futurePointsScored,futurePointsTotal,futureFinalTokenBalance);
      }

      //updates the starting token balanace, points, total points, and final token balance of a given row (based on periodNumber)
      function updateFutureRowByPeriod(periodNumber,startingTokenBalance,pointsScored,totalPoints,finalTokenBalance){
        let rowToUpdate = document.getElementById(`row-period-${periodNumber}`);
        let startingTokenBalanceTableDataElem = document.getElementById(`starting-token-balance-${periodNumber}`);
        let pointsTableDataElem = document.getElementById(`points-data-${periodNumber}`);
        let totalPointsTableDataElem = document.getElementById(`total-points-${periodNumber}`)
        let finalTokenBalanceTableDataElem = document.getElementById(`final-token-balance-${periodNumber}`)

        startingTokenBalanceTableDataElem.innerHTML = startingTokenBalance.toFixed(2);
        pointsTableDataElem.innerHTML = pointsScored.toFixed(2);
        totalPointsTableDataElem.innerHTML = totalPoints.toFixed(2);
        finalTokenBalanceTableDataElem.innerHTML = finalTokenBalance.toFixed(2);
      }

      //appends input values to current row
      // these points, total points, and final token balance 
      async function updateCurrentRow(pointsScored,totalPoints,finalTokenBalance){
        let currRow = document.getElementById(`row-period-${js_vars.player_round_number}`);
        let pointsTableDataElem = document.getElementById(`points-data-${js_vars.player_round_number}`)
        let totalPointsTableDataElem = document.getElementById(`total-points-${js_vars.player_round_number}`)
        let finalTokenBalanceTableDataElem = document.getElementById(`final-token-balance-${js_vars.player_round_number}`)

        pointsTableDataElem.innerHTML = pointsScored.toFixed(2);
        totalPointsTableDataElem.innerHTML = totalPoints.toFixed(2);
        finalTokenBalanceTableDataElem.innerHTML = finalTokenBalance.toFixed(2);
        
        return js_vars.player_round_number+1;
      }
    </script>

  </div>
</div>