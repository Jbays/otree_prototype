{% load otree %}

<div class="card bg-light m-3">
  <div class="card-body decision-box">
    <div class="titleContainer">
      <div class="flexContainer">
        <div class="titleDash"></div>
        <div class="title">
          Budgeting Calculator
        </div>
      </div>
    </div>

    <style>
      button {
        border: none;
        border-radius: 2px;
        box-shadow: 0px 0px 5px 0px rgba(196, 196, 196, 1);
        padding: 4px 12px;
        min-width: 120px;
      }

      table,
      td {
        border: 1px solid #272d38;
      }

      tr:nth-child(even) {
        background-color: #343c4a;
      }

      thead,
      tfoot {
        background-color: #272d38;
        color: #fff;
      }

      .m-3 {
        margin: 1.5rem 0 0 0 !important
      }

      #myTable {
        text-align: center;
        margin: 0 auto 1.25rem auto;
        width: 100%;
      }
    </style>

    <table id="myTable">
      <tbody style="text-align: center;" id="table_body">

      </tbody>
    </table>

    <div style="text-align: center;">
      <button onClick=resetTableVals(event)>Reset values</button>
      <button style="background-color: red;" onClick=calculateTableVals(event)>Calculate</button>
    </div>


    <div id="total_number_of_periods_container" style="display:none">{{Constants.num_rounds}}</div>


    <!-- here are the constants and calculator helpers -->
    <script>
      // console.log('totalNumberOfPeriods',totalNumberOfPeriods)

      // TODO: 15 Oct
      // in next iteration, this object will need to be created based on config values
      // which are in turn passed thru the backend to the front (via js_vars)
      const instructionsOnHowToIncrementPast = {
        "period": 'increment',
        "income": "constant",
        "cost_per_unit": "constant",
        "inflation": "constant",
        "interest_rate": "constant",
        "start_token_balance": "js_vars_lookup",
        "purchased_unit": "js_vars_lookup",
        "final_token_balance": "js_vars_lookup",
      };

      const instructionsOnHowToIncrement = {
        "period": 'increment',
        "income": "constant",
        "cost_per_unit": "constant",
        "inflation": "constant",
        "interest_rate": "constant",
        // note that this is the most_recent_final_token_balance
        "start_token_balance": ["income+(interest_rate*final_token_balance)"],
        "purchased_unit": "input",
        "final_token_balance": ["start_token_balance-(purchased_units*cost_per_unit)"],
      };

      const instructionOnHowToIncrementFuture = {
        "period": "increment",
        "income": "constant",
        "cost_per_unit": "constant",
        "inflation": "constant",
        "interest_rate": "constant",
        "start_token_balance": ["income+(interest_rate*final_token_balance)"],
        "purchased_unit": "input",
        "final_token_balance": ["start_token_balance-(purchased_units*cost_per_unit)"],
      }

      // input is the key name
      // output is the expected value at a given period
      function calculateValueBasedOnProptype(keyName) {
        if (keyName === 'period') {
          return currentPeriod;
        }

        // handle period first
        // then the rest will be trickier
        if (instructionsOnHowToIncrement.hasOwnProperty(keyName)) {
          let proptype = instructionsOnHowToIncrement[keyName];

          // console.log('proptype',proptype);

          if (proptype === 'constant') {
            return js_vars[keyName]
          }
          if (proptype === 'js_vars_lookup') {
            console.log(js_vars[`${keyName}_across_all_rounds`])
            // return js_vars[`${keyName}_across_all_rounds`][currentPeriod-2]
          }
        }
      }

      // maybe this function can be passed all the required constants?  Then it can make the calculation itself.
      function calculateFutureValueBasedOnProptype(keyName, futurePeriod, income, costPerUnit, inflation, interestRate, startTokenBalance) {
        if (keyName === 'period') {
          return futurePeriod + 1;
        };

        if (keyName === 'purchased_unit') {
          return null;
        }

        if (keyName === 'start_token_balance' || keyName === 'final_token_balance') {
          let num_of_rounds_in_future = (futurePeriod - currentPeriod) + 1;
          // console.log('num_of_rounds_in_future',num_of_rounds_in_future)
          let futureTokenBalance = (startTokenBalance + (income * num_of_rounds_in_future)) * ((100 + interestRate) / 100);
          return futureTokenBalance
        }

        if (keyName === 'income') {
          return income;
        }

        if (keyName === 'interest_rate') {
          return interestRate;
        }

        if (keyName === 'inflation') {
          return inflation;
        }

        if (keyName === 'cost_per_unit') {
          return costPerUnit;
        }
      }
    </script>

    <!-- new set of calculator helper functions.  Trying to consider this problem with clarity -->
    <script>
      console.log('js_vars', js_vars);
      const currentPeriod = js_vars.current_period;
      const costPerUnit = js_vars.cost_per_unit;
      const incomeConst = js_vars.income;
      const interestRateConst = js_vars.interest_rate;
      const startTokenBalanceMostRecent = js_vars.start_token_balance_upcoming;
      const totalNumberOfPeriods = Number(document.getElementById('total_number_of_periods_container').innerHTML);
      const inflationConst = js_vars.inflation;
      const futureHorizonViewableConst = js_vars.future_horizon_viewable;
      const pastHorizonViewableConst = js_vars.past_horizon_viewable;

      let defaultPurchasedUnit = document.createElement('input');
      defaultPurchasedUnit.type = "number";
      defaultPurchasedUnit.min = 0;
      defaultPurchasedUnit.style.cssText = "background-color:#ffbbff;text-align:center";

      function keyNameExtractor(arrayOfObjs) {
        let output = []

        arrayOfObjs.forEach((elem) => {
          if (elem.hasOwnProperty('name_of_field')) {
            output.push(elem.name_of_field);
          }
        })

        return output
      }

      function startValueExtractor(arrayOfObjs) {
        let output = []

        arrayOfObjs.forEach((elem) => {
          let keyName = elem.name_of_field;
          if (elem.hasOwnProperty('start_val')) {
            let startValType = typeof elem.start_val;

            if (startValType === 'number') {
              output.push(elem.start_val);
            } else if (startValType === 'string') {
              if (elem.start_val === 'look-up') {
                output.push(js_vars[keyName])
              } else if (elem.start_val === 'input') {
                output.push(`${keyName}-input`)
              }
            }
          }
        })

        return output
      }

      // let columnRulesForPastRows = processConfigObjsToInstructions(js_vars.the_calculator_config[0]);
      // let columnRulesForCurrentRows = processConfigObjsToInstructions(js_vars.the_calculator_config[0],"current_type");
      let columnRulesForFutureRows = processConfigObjsToInstructions(js_vars.the_calculator_config[0], "future_type");

      function processConfigObjsToInstructions(array, keyDesired) {
        let output = [];

        array.forEach((elem) => {
          if (elem.hasOwnProperty('future_type')) {
            output.push(elem.future_type);
          };
        });

        return output;
      };

    </script>


    <!-- here are the main calculator functions -->
    <script>
      // creates the row, creates the table data elements, to those elements adds the correct label
      // appends those elements the row, then appends the row to the budgeting calculator
      function appendColumnNamesToTable(table, array) {
        let columnHeadersRow = document.createElement('tr');

        array.forEach((columnName) => {
          let columnTableData = document.createElement('td');
          columnTableData.innerHTML = columnName;
          columnTableData.style.cssText = "padding:.25em";
          columnHeadersRow.appendChild(columnTableData);
        })

        columnHeadersRow.style.cssText = "background-color:chartreuse";
        table.appendChild(columnHeadersRow);
      };

      // append the array of values to the table.
      // NOTE: this will only work with purchased_unit
      function appendCurrentRow(table, array, period) {
        let thisPeriodsRow = document.createElement('tr');

        array.forEach((dataElem) => {
          let tableDataElem = document.createElement('td');
          let dataElemType = typeof dataElem;

          if (dataElemType === 'number') {
            tableDataElem.innerHTML = dataElem;
          } else if (dataElemType === 'string') {
            let inputRequired = dataElem.split('-')[0];

            if (inputRequired === 'purchased_unit') {
              tableDataElem = defaultPurchasedUnit.cloneNode(true);
              tableDataElem.id = `${inputRequired}-input-${period}`;
            }
            //NOTE: here is where you'd add more extensible logic to handle the other input cases
            // else if ( inputRequired === 'something new' ){}
          };
          thisPeriodsRow.appendChild(tableDataElem);
        });

        thisPeriodsRow.style.cssText = "background-color:white";
        table.appendChild(thisPeriodsRow);
      };

      function appendFutureRows(table, keyNamesArr, startValuesArr, columnRulesArr, period, totalPeriods, futureHorizon) {
        console.log('table', table);
        console.log('keyNamesArr', keyNamesArr);
        console.log('startValuesArr', startValuesArr);
        console.log('columnRulesArr', columnRulesArr);
        console.log('period', period);
        console.log('totalPeriods', totalPeriods);
        console.log('futureHorizon', futureHorizon);

        // then all this code will have to be x number of times
        // where x equals the future horizon viewable UPTO the total periods in the entire game

        // totalViewablePeriods
        // if future horizon is greater than total periods, then show total periods.  Else, only show period + future horizon
        let totalViewablePeriods = (futureHorizon > totalPeriods) ? totalPeriods : (period + futureHorizon)

        for (let futureRow = period + 1; futureRow < totalViewablePeriods; futureRow++) {
          console.log('futureRow', futureRow);

          let futurePeriodRow = document.createElement('tr');

          keyNamesArr.forEach((keyName, index) => {
            let tableDataElem = document.createElement('td');
            let whatToDoWithKeyName = columnRulesArr[index];

            //NOTE: this is pretty assumptive.  :/
            // what about an increment value other than period?
            if (whatToDoWithKeyName === 'increment') {
              // this'll be updated!
              tableDataElem.innerHTML = futureRow;
            } else if (whatToDoWithKeyName === 'constant') {
              tableDataElem.innerHTML = startValuesArr[index];
            } else if (whatToDoWithKeyName === 'calculate') {

              if (keyName === 'start_token_balance' || keyName === 'final_token_balance') {
                let income = js_vars.income;
                let interestRateDecimal = (100 + js_vars.interest_rate) / 100;
                // this'll be updated!
                let numberOfRoundsInTheFuture = futureRow - 1;

                if (period === 1) {
                  tableDataElem.innerHTML = (js_vars.start_token_balance + (income * numberOfRoundsInTheFuture)) * interestRateDecimal;
                } else {
                  tableDataElem.innerHTML = (js_vars.final_token_balance_most_recent + (income * numberOfRoundsInTheFuture)) * interestRateDecimal;
                }
                tableDataElem.id = `${keyName}-${futureRow}`;
              }
            } else if (whatToDoWithKeyName === 'input') {
              if (keyName === 'purchased_unit') {
                tableDataElem = defaultPurchasedUnit.cloneNode(true);
                tableDataElem.id = `${keyName}-input-${futureRow}`;
              }
            }

            futurePeriodRow.appendChild(tableDataElem);
          });

          table.appendChild(futurePeriodRow);

        }


      }

      function assembleNewCalculator(configVariableObject, period, totalPeriods, futureHorizon, pastHorizon) {
        let budgetingCalculator = document.getElementById('myTable');
        let arrayOfKeynames = keyNameExtractor(configVariableObject[0]);
        let arrayOfStartValues = startValueExtractor(configVariableObject[0]);

        appendColumnNamesToTable(budgetingCalculator, arrayOfKeynames);

        if (period === 1) {
          console.log('youre here!')
          appendCurrentRow(budgetingCalculator, arrayOfStartValues, period);
          appendFutureRows(budgetingCalculator, arrayOfKeynames, arrayOfStartValues, columnRulesForFutureRows, period, totalPeriods, futureHorizon);
          // append future rows
        } else {
          // append past rows

          // append current row
          // append future rows

        }

      }

      assembleNewCalculator(js_vars.the_calculator_config, currentPeriod, totalNumberOfPeriods, futureHorizonViewableConst, pastHorizonViewableConst);

      // below is deprecated.

      function assembleCalculator(configVariableObject) {
        let theTable = document.getElementById('myTable');

        // put the name and start_val in a tuple.  And that tuple into a container array.  Then use that array to create the table headers.
        let onlyNamesStartValAndPositionArr = [];
        for (let i = 0; i < configVariableObject[0].length; i++) {
          let arr = [];

          // handle strings, numbers, bools in this fashion
          if (configVariableObject[0][i].hasOwnProperty('name_of_field')) {
            arr.push(configVariableObject[0][i].name_of_field)
          }

          if (configVariableObject[0][i].hasOwnProperty('start_val')) {
            let columnName = arr[0]

            // if lookup, then double-check value is in js_vars
            if (configVariableObject[0][i].start_val === 'look-up' && js_vars.hasOwnProperty(columnName)) {
              arr.push(js_vars[columnName])
            } else {
              arr.push(configVariableObject[0][i].start_val)
            }
          }

          onlyNamesStartValAndPositionArr.push(arr)
        }

        if (currentPeriod === 1) {
          attachColumnHeadersAndInitialValues(theTable, onlyNamesStartValAndPositionArr);
          appendFutureRows(theTable, onlyNamesStartValAndPositionArr);

        } else {
          // no way this is the best way --> but let's get this working asap.  I'll clean up afterward.
          appendPastPeriodData(theTable, onlyNamesStartValAndPositionArr)
          appendCurrentPeriodData(theTable, onlyNamesStartValAndPositionArr)
          appendFutureRows(theTable, onlyNamesStartValAndPositionArr)
        }
      };

      // responsible for appending all past rows
      function appendPastPeriodData(table, array) {
        let allColumnHeaders = document.createElement('tr');
        let firstPeriodData = document.createElement('tr');
        allColumnHeaders.style.cssText = "background-color:chartreuse";

        // purchased units and final token balance require special treatment since they're derived values --> not simple "go and look up"
        // one is from the user, one is derived

        // first you can ONLY append the column names
        array.forEach((columnTuple) => {
          let name = columnTuple[0];
          let nameTableData = document.createElement('td');
          nameTableData.innerHTML = name;
          nameTableData.style.cssText = "padding:.25em";

          allColumnHeaders.appendChild(nameTableData);
        });

        table.appendChild(allColumnHeaders);

        // for all periods passed up to the past horizon viewable config variable

        // these are columns
        for (let tableColumn = 0; tableColumn < array.length; tableColumn++) {
          // create the jth loop 
          // if the viewable horizon is greater than the currentPeriod
          if (currentPeriod < js_vars.past_horizon_viewable) {
            // special case
            // if its the second period && the current period is less than the permissable / viewable horizon 
            if (currentPeriod === 2) {
              let name = array[tableColumn][0];
              let startVal = array[tableColumn][1];
              let mostRecentUnitPurchase = Number(js_vars.purchased_units_across_all_rounds[0]);

              let startValTableData = document.createElement('td');
              startValTableData.id = `${name}-2`;

              //how to remove the hard-coding here?
              // pass boolean which separates these "lookup / dependent" variables
              if (name === 'purchased_unit') {
                startValTableData.innerHTML = mostRecentUnitPurchase;
              } else if (name === 'final_token_balance') {
                startValTableData.innerHTML = js_vars.start_token_balance - (mostRecentUnitPurchase * costPerUnit);
              } else {
                startValTableData.innerHTML = startVal;
              }

              firstPeriodData.style.cssText = "background-color:white";
              firstPeriodData.appendChild(startValTableData);
              table.appendChild(firstPeriodData);
            } else {
              // 
              for (let pastRow = 1; pastRow < currentPeriod; pastRow++) {
                console.log('this is pastRow', pastRow)
              }
            }

          }
        }
      }

      function appendCurrentPeriodData(table, array) {
        console.log('appendCurrentPeriodData');
        // for each column name in the array,
        // "read the name" then figure out what you need to do based on the name.
        // maybe I don't need to loop through the array I'm passing but the original config?
        let currentRow = document.createElement('tr');
        array.forEach((elem) => {
          let keyName = elem[0];

          // how to signify that some column elements should be inputs?
          // put this in the JSON?
          // currentValIsInput = true?
          if (keyName === 'purchased_unit') {
            let purchasedUnitsInputClone = defaultPurchasedUnit.cloneNode(true);
            purchasedUnitsInputClone.id = `${keyName}-input-${currentPeriod}`;
            currentRow.appendChild(purchasedUnitsInputClone);
          } else if (keyName === 'start_token_balance' || keyName === 'final_token_balance') {
            let keyNameTableData = document.createElement('td');
            keyNameTableData.id = `${keyName}-${currentPeriod}`;
            keyNameTableData.innerHTML = js_vars.start_token_balance_upcoming;
            currentRow.appendChild(keyNameTableData);
          } else {
            let keyNameTableData = document.createElement('td');
            keyNameTableData.id = `${keyName}-${currentPeriod}`;
            let currentValue = calculateValueBasedOnProptype(keyName);

            keyNameTableData.innerHTML = currentValue
            currentRow.appendChild(keyNameTableData);
          }
        })
        table.appendChild(currentRow)
      }

      // function appendFutureRows(table,array){
      //   console.log('appendFutureRows');

      //   for ( let futureRow = currentPeriod; futureRow < futureHorizonViewableConst; futureRow++ ) {
      //     console.log('futureRow',futureRow);
      //     let futureTableRow = document.createElement('tr');
      //     array.forEach((elem)=>{
      //       let keyName = elem[0];
      //       if ( keyName === 'purchased_unit' ) {
      //         let purchasedUnitsInputClone = defaultPurchasedUnit.cloneNode(true);
      //         purchasedUnitsInputClone.id = `${keyName}-input-${futureRow}`;
      //         futureTableRow.appendChild(purchasedUnitsInputClone);
      //       } else {
      //         let keyNameTableData = document.createElement('td');
      //         keyNameTableData.id = `${keyName}-${futureRow}`;
      //         let futureVal = calculateFutureValueBasedOnProptype(keyName,futureRow, incomeConst, costPerUnit,inflationConst, interestRateConst,startTokenBalanceMostRecent);
      //         keyNameTableData.innerHTML = futureVal;
      //         futureTableRow.appendChild(keyNameTableData);
      //       };
      //     });
      //     table.appendChild(futureTableRow);
      //   }
      // }

      function attachColumnHeadersAndInitialValues(table, array) {
        let columnHeaders = document.createElement('tr');
        let startingValues = document.createElement('tr');

        for (let i = 0; i < array.length; i++) {
          let name = array[i][0];
          let startVal = array[i][1];

          let nameTableData = document.createElement('td');
          let startValTableData = document.createElement('td');
          startValTableData.id = `${name}-${i}`;

          nameTableData.innerHTML = name;
          startValTableData.innerHTML = startVal;

          columnHeaders.appendChild(nameTableData)

          if (name !== 'purchased_unit') {
            startingValues.appendChild(startValTableData)
          } else {
            // must handle purchased_unit different since its an input not a primitive data type
            let purchasedUnitsInputClone = defaultPurchasedUnit.cloneNode(true);
            purchasedUnitsInputClone.id = 'purchased-unit-input-1';
            startingValues.appendChild(purchasedUnitsInputClone);
          }
        }

        columnHeaders.style.cssText = "background-color:chartreuse";

        table.appendChild(columnHeaders);
        table.appendChild(startingValues);
      }


    </script>

    <script>
    //   function resetTableVals(event){
    //     event.preventDefault();

    //     //grab purchased units element, points, total points, and final token balance
    //     let startTokenBalance_ThisPeriod = Number(document.getElementById(`start-token-balance-${js_vars.current_period}`).innerHTML);
    //     let purchasedUnitsElem_ThisPeriod = document.getElementById(`purchased-unit-input-${js_vars.current_period}`);
    //     let pointsElem_ThisPeriod = document.getElementById(`points-${js_vars.current_period}`);
    //     let totalPointsElem_ThisPeriod = document.getElementById(`total-points-${js_vars.current_period}`);
    //     let finalTokenBalanceElem_ThisPeriod = document.getElementById(`final-token-balance-${js_vars.current_period}`);

    //     purchasedUnitsElem_ThisPeriod.value = '';
    //     pointsElem_ThisPeriod.innerHTML = 0;
    //     totalPointsElem_ThisPeriod.innerHTML = 0;
    //     finalTokenBalanceElem_ThisPeriod.innerHTML = startTokenBalance_ThisPeriod;

    //     //if period is even, only reset values from the second row
    //     if ( js_vars.current_period % 2 === 0 ) {
    //       console.log('period is even!');
    //     } else {
    //       console.log('period is odd!');

    //       // purchasedUnitsElem_ThisPeriod.value = '';
    //       // pointsElem_ThisPeriod.innerHTML = 0;
    //       // totalPointsElem_ThisPeriod.innerHTML = 0;
    //       // finalTokenBalanceElem_ThisPeriod.innerHTML = startTokenBalance_ThisPeriod;

    //       //calc player income for next period
    //       let income_NextPeriod = calculatePlayerIncomeByPeriod(paySequenceThisDecision,incomeConst,js_vars.current_period+1);

    //       //starting token balance for next period is equal to:
    //       //next period's income + (this period's final token balance * interest_rate )
    //       let startTokenBalance_NextPeriod = income_NextPeriod + (Number(finalTokenBalanceElem_ThisPeriod.innerHTML)*(1+(Number(interestRateThisDecision)*.01)));

    //       let startTokenBalanceElem_NextPeriod = document.getElementById(`start-token-balance-${js_vars.current_period+1}`);
    //       // console.log('income_NextPeriod',income_NextPeriod);
    //       // console.log('startTokenBalance_NextPeriod',startTokenBalance_NextPeriod);
    //       let purchasedUnitsElem_NextPeriod = document.getElementById(`purchased-unit-input-${js_vars.current_period+1}`)
    //       let pointsElem_NextPeriod = document.getElementById(`points-${js_vars.current_period+1}`);
    //       let totalPointsElem_NextPeriod = document.getElementById(`total-points-${js_vars.current_period+1}`);
    //       let finalTokenBalanceElem_NextPeriod = document.getElementById(`final-token-balance-${js_vars.current_period+1}`);

    //       startTokenBalanceElem_NextPeriod.innerHTML = startTokenBalance_NextPeriod;
    //       purchasedUnitsElem_NextPeriod.value = '';
    //       pointsElem_NextPeriod.innerHTML = 0;
    //       totalPointsElem_NextPeriod.innerHTML = 0;
    //       finalTokenBalanceElem_NextPeriod.innerHTML = startTokenBalance_NextPeriod;
    //     }

    //     console.log('calculator values reset!')
    //   }


    //   function calculateTableVals(event){
    //     event.preventDefault()
    //     if ( js_vars.current_period % 2 === 0 ){
    //       let startTokenBalance = Number(document.getElementById(`start-token-balance-${js_vars.current_period}`).innerText);
    //       let futureUnitPurchase_ThisPeriod = Number(document.getElementById(`purchased-unit-input-${js_vars.current_period}`).value);
    //       let pointsScored_ThisPeriod = calcNaturalLog(futureUnitPurchase_ThisPeriod);

    //       let points_ThisPeriod = document.getElementById(`points-${js_vars.current_period}`);
    //       points_ThisPeriod.innerHTML = pointsScored_ThisPeriod;

    //       let totalPoints_PrevPeriod = document.getElementById(`total-points-${js_vars.current_period-1}`);
    //       // let finalTokenBalance_PrevPeriod = document.getElementById(`final-token-balance-${js_vars.current_period-1}`);

    //       // console.log('totalPoints_PrevPeriod',totalPoints_PrevPeriod)
    //       // console.log('finalTokenBalance_PrevPeriod',finalTokenBalance_PrevPeriod)

    //       let totalPoints_ThisPeriod = document.getElementById(`total-points-${js_vars.current_period}`);
    //       totalPoints_ThisPeriod.innerHTML = (Number(totalPoints_PrevPeriod.innerText)+pointsScored_ThisPeriod).toFixed(2);
    //       let finalTokenBalance_ThisPeriod = document.getElementById(`final-token-balance-${js_vars.current_period}`);
    //       finalTokenBalance_ThisPeriod.innerHTML = (startTokenBalance-(futureUnitPurchase_ThisPeriod*costPerUnitConst)).toFixed(2);

    //     } else {
    //       let startTokenBalance = Number(document.getElementById(`start-token-balance-${js_vars.current_period}`).innerText);
    //       let futureUnitPurchase_ThisPeriod = Number(document.getElementById(`purchased-unit-input-${js_vars.current_period}`).value);
    //       let pointsScored_ThisPeriod = calcNaturalLog(futureUnitPurchase_ThisPeriod);

    //       let points_ThisPeriod = document.getElementById(`points-${js_vars.current_period}`);
    //       points_ThisPeriod.innerHTML = pointsScored_ThisPeriod
    //       let totalPoints_ThisPeriod = document.getElementById(`total-points-${js_vars.current_period}`);
    //       totalPoints_ThisPeriod.innerHTML = pointsScored_ThisPeriod;
    //       let finalTokenBalance_ThisPeriod = document.getElementById(`final-token-balance-${js_vars.current_period}`);
    //       finalTokenBalance_ThisPeriod.innerHTML = startTokenBalance-(futureUnitPurchase_ThisPeriod*costPerUnitConst);

    //       //if period is odd, then do more work!
    //       let income_NextPeriod = calculatePlayerIncomeByPeriod(paySequenceThisDecision,incomeConst,js_vars.current_period+1);

    //       //starting token balance for next period is equal to:
    //       //next period's income + (this period's final token balance * interest_rate )
    //       let startTokenBalance_NextPeriod = document.getElementById(`start-token-balance-${js_vars.current_period+1}`);

    //       startTokenBalance_NextPeriod.innerHTML = income_NextPeriod+(Number(finalTokenBalance_ThisPeriod.innerHTML)*(1+(Number(interestRateThisDecision)*.01)));

    //       //then get purchased units from second input,
    //       let futureUnitPurchase_NextPeriod = Number(document.getElementById(`purchased-unit-input-${js_vars.current_period+1}`).value);
    //       let pointsScored_NextPeriod = calcNaturalLog(futureUnitPurchase_NextPeriod);

    //       let points_NextPeriod = document.getElementById(`points-${js_vars.current_period+1}`);
    //       points_NextPeriod.innerHTML = pointsScored_NextPeriod;

    //       //total points is equal to this period's total points + next period's total points!
    //       let totalPoints_NextPeriod = document.getElementById(`total-points-${js_vars.current_period+1}`);
    //       //rounded to the nearest two decimal places
    //       totalPoints_NextPeriod.innerHTML = (Number(points_ThisPeriod.innerHTML)+Number(points_NextPeriod.innerHTML)).toFixed(2);

    //       let finalTokenBalance_NextPeriod = document.getElementById(`final-token-balance-${js_vars.current_period+1}`);
    //       finalTokenBalance_NextPeriod.innerHTML = Number(startTokenBalance_NextPeriod.innerHTML) - (futureUnitPurchase_NextPeriod*costPerUnitConst);
    //       //calc points, total points, and final token balance
    //     }
    //     console.log('calculator updated!');
    //   }

    //   //returns the natural log of input num
    //   //rounded to two decimal places
    //   function calcNaturalLog(num){
    //     if ( num === 0 ) {
    //       return 0
    //     }
    //     return Number((Math.log(num)/Math.log(Math.E)).toFixed(2))
    //   }

    //   //key: pay_sequence=0 then pay upfront, 
    //   //     pay_sequence=1 then pay last round,
    //   //     pay_sequence=2, then pay half each round
    //   //inputs: pay sequence, income, and period
    //   //returns: the token balance (num) for a given period
    //   function calculatePlayerIncomeByPeriod(pay_sequence,income,period){
    //     //if pay sequence is equal split between rounds
    //     if ( pay_sequence === 2 ) {
    //       return income/2
    //     }
    //     //if period is odd
    //     if ( period % 2 === 1 ) {
    //       //pay upfront
    //       if ( pay_sequence === 0 ) {
    //         return income
    //       } //this is first period for pay second period
    //       else if ( pay_sequence === 1 ) {
    //         return 0
    //       }
    //     } else {
    //     //periods are even
    //       //already paid upfront
    //       if ( pay_sequence === 0 ) {
    //         return 0
    //       } else if ( pay_sequence === 1 ) {
    //         return income
    //       }
    //     }
    //   }

    //   // console.log('decToChoiceMatrix',decToChoiceMatrix);
    //   // console.log('inflationThisDecision',inflationThisDecision);
    //   // console.log('interestRateThisDecision',interestRateThisDecision);
    //   // console.log('paySequenceThisDecision',paySequenceThisDecision);

    //   onPageLoad(incomeConst,costPerUnitConst,inflationThisDecision,interestRateThisDecision,paySequenceThisDecision,js_vars.current_period);
    //   // onPageLoad(constantsNumberOfRounds,constantsPricePerUnit);

    //   function onPageLoad(income,cost_per_unit,inflation,interest_rate,pay_sequence,period){
    //     let myTable = document.getElementById('myTable');

    //     if ( period % 2 === 1 ) {
    //       oddPeriodTableSetUp(myTable,pay_sequence,period,income,cost_per_unit,inflation,interest_rate)
    //     } else {
    //       evenPeriodAppendToTable(myTable,pay_sequence,period,income,cost_per_unit,inflation,interest_rate);
    //     }

    //     function evenPeriodAppendToTable(table,pay_sequence,period,income,price_per_unit,inflation,interest_rate){
    //       let unitsPurchased_PrevPeriod = js_vars.purchased_units_across_all_rounds[period-2];
    //       // console.log('unitsPurchased_PrevPeriod',unitsPurchased_PrevPeriod)
    //       // console.log(table)
    //       // console.log(pay_sequence)
    //       // console.log(period)
    //       // console.log(income)
    //       // console.log(price_per_unit)
    //       // console.log(inflation)
    //       // console.log(interest_rate)

    //       let prevRow = document.createElement('tr');
    //       //append values from previous round

    //       let periodElem_PrevPeriod = document.createElement('td');
    //           periodElem_PrevPeriod.innerText = 1;

    //       let incomeElem_PrevPeriod = document.createElement('td');
    //           incomeElem_PrevPeriod.innerText = calculatePlayerIncomeByPeriod(pay_sequence,income,period-1);

    //       let pricePerUnitElem_PrevPeriod = document.createElement('td');
    //           pricePerUnitElem_PrevPeriod.innerText = costPerUnitConst;
    //       let inflationElem_PrevPeriod = document.createElement('td');
    //           inflationElem_PrevPeriod.innerText = inflation;
    //       let interestRateElem_PrevPeriod = document.createElement('td');
    //           interestRateElem_PrevPeriod.innerText = interest_rate;

    //       //for even rounds, the previous period's starting token balance equals the income from that round
    //       let startTokenBalanceElem_PrevPeriod = document.createElement('td');
    //           startTokenBalanceElem_PrevPeriod.id = `start-token-balance-${period-1}`;
    //           startTokenBalanceElem_PrevPeriod.innerText = incomeElem_PrevPeriod.innerText;

    //       let unitsPurchasedElem_PrevPeriod = document.createElement('td');
    //           unitsPurchasedElem_PrevPeriod.id = `purchased-unit-input-${period-1}`;
    //           unitsPurchasedElem_PrevPeriod.innerText = unitsPurchased_PrevPeriod;

    //       let pointsElem_PrevPeriod = document.createElement('td');
    //           pointsElem_PrevPeriod.id = `points-${period-1}`;
    //           pointsElem_PrevPeriod.innerText = calcNaturalLog(unitsPurchased_PrevPeriod).toFixed(2);
    //       let totalPointsElem_PrevPeriod = document.createElement('td');
    //           totalPointsElem_PrevPeriod.id = `total-points-${period-1}`;
    //           totalPointsElem_PrevPeriod.innerText = pointsElem_PrevPeriod.innerText;
    //       let finalTokenBalanceElem_PrevPeriod = document.createElement('td');
    //           finalTokenBalanceElem_PrevPeriod.id = `final-token-balance-${period-1}`;
    //           finalTokenBalanceElem_PrevPeriod.innerText = Number(incomeElem_PrevPeriod.innerText) - (unitsPurchased_PrevPeriod*costPerUnitConst);

    //       prevRow.appendChild(periodElem_PrevPeriod);
    //       prevRow.appendChild(incomeElem_PrevPeriod);
    //       prevRow.appendChild(pricePerUnitElem_PrevPeriod);
    //       prevRow.appendChild(inflationElem_PrevPeriod);
    //       prevRow.appendChild(interestRateElem_PrevPeriod);
    //       prevRow.appendChild(startTokenBalanceElem_PrevPeriod);
    //       prevRow.appendChild(unitsPurchasedElem_PrevPeriod);
    //       prevRow.appendChild(pointsElem_PrevPeriod);
    //       prevRow.appendChild(totalPointsElem_PrevPeriod);
    //       prevRow.appendChild(finalTokenBalanceElem_PrevPeriod);

    //       table.appendChild(prevRow);

    //       let currRow = document.createElement('tr');
    //       //append period, income, price per unit, interest rate, token balance, purchased Units, points, total points, final token balance

    //       let periodElem_CurrPeriod = document.createElement('td');
    //           periodElem_CurrPeriod.innerText = 2;

    //       let incomeElem_CurrPeriod = document.createElement('td');
    //           incomeElem_CurrPeriod.innerText = calculatePlayerIncomeByPeriod(pay_sequence,income,period);

    //       let pricePerUnitElem_CurrPeriod = document.createElement('td');
    //           pricePerUnitElem_CurrPeriod.innerText = costPerUnitConst;
    //       let inflationElem_CurrPeriod = document.createElement('td');
    //           inflationElem_CurrPeriod.innerText = inflation;
    //       let interestRateElem_CurrPeriod = document.createElement('td');
    //           interestRateElem_CurrPeriod.innerText = interest_rate;

    //       //for current period, starting token balance is equal to final token balance * interest_rate + income
    //       let startTokenBalanceElem_CurrPeriod = document.createElement('td');
    //           startTokenBalanceElem_CurrPeriod.id = `start-token-balance-${period}`;
    //           startTokenBalanceElem_CurrPeriod.innerText = (Number(finalTokenBalanceElem_PrevPeriod.innerText)*(1+(Number(interest_rate)*.01))) + Number(incomeElem_CurrPeriod.innerText);

    //       //fix for units_purchased, points, toal points, and final token balance.
    //       let unitsPurchasedElem_CurrPeriod = document.createElement('input');
    //           unitsPurchasedElem_CurrPeriod.type = "number";
    //           unitsPurchasedElem_CurrPeriod.min = 0;
    //           unitsPurchasedElem_CurrPeriod.id = `purchased-unit-input-${period}`;
    //           unitsPurchasedElem_CurrPeriod.style.cssText = "background-color:#ffbbff;text-align:center";

    //       let pointsElem_CurrPeriod = document.createElement('td');
    //           pointsElem_CurrPeriod.id = `points-${period}`;
    //           pointsElem_CurrPeriod.innerHTML = 0;

    //       let totalPointsElem_CurrPeriod = document.createElement('td');
    //           totalPointsElem_CurrPeriod.id = `total-points-${period}`;
    //           totalPointsElem_CurrPeriod.innerText = 0;

    //       let finalTokenBalanceElem_CurrPeriod = document.createElement('td');
    //       finalTokenBalanceElem_CurrPeriod.id = `final-token-balance-${period}`
    //       finalTokenBalanceElem_CurrPeriod.innerText = startTokenBalanceElem_CurrPeriod.innerText

    //       currRow.appendChild(periodElem_CurrPeriod);
    //       currRow.appendChild(incomeElem_CurrPeriod);
    //       currRow.appendChild(pricePerUnitElem_CurrPeriod);
    //       currRow.appendChild(inflationElem_CurrPeriod);
    //       currRow.appendChild(interestRateElem_CurrPeriod);
    //       currRow.appendChild(startTokenBalanceElem_CurrPeriod);
    //       currRow.appendChild(unitsPurchasedElem_CurrPeriod);
    //       currRow.appendChild(pointsElem_CurrPeriod);
    //       currRow.appendChild(totalPointsElem_CurrPeriod);
    //       currRow.appendChild(finalTokenBalanceElem_CurrPeriod);

    //       table.appendChild(currRow);
    //     }

    //     //create various table elements, append input values to these table elements
    //     function oddPeriodTableSetUp(table,pay_sequence,period,income,price_per_unit,inflation,interest_rate){
    //       //create table elements for period, income, price per unit, inflation, interest rate, token balance,
    //       //purchased units, points, total points, final token balance
    //       let currRow = document.createElement('tr');

    //       let period_TableElem1 = document.createElement('td');
    //           period_TableElem1.innerHTML = 1;

    //       let income_TableElem1 = document.createElement('td');
    //           income_TableElem1.innerHTML = Number(calculatePlayerIncomeByPeriod(pay_sequence,income,period));

    //       let pricePerUnit_TableElem1 = document.createElement('td');
    //           pricePerUnit_TableElem1.innerHTML = price_per_unit;

    //       let inflation_TableElem1 = document.createElement('td');
    //           inflation_TableElem1.innerHTML = inflation;

    //       let interestRate_TableElem1 = document.createElement('td');
    //           interestRate_TableElem1.innerHTML = Number(interest_rate);

    //       let tokenBalance_TableElem1 = document.createElement('td');
    //           tokenBalance_TableElem1.id = `start-token-balance-${period}`;
    //           tokenBalance_TableElem1.innerHTML = income_TableElem1.innerHTML;

    //       let purchasedUnits_TableElem1 = document.createElement('input');
    //           purchasedUnits_TableElem1.type = "number";
    //           purchasedUnits_TableElem1.min = 0;
    //           purchasedUnits_TableElem1.id = `purchased-unit-input-${period}`;
    //           purchasedUnits_TableElem1.style.cssText = "background-color:#ffbbff;text-align:center";

    //       let points_TableElem1 = document.createElement('td');
    //           points_TableElem1.id = `points-${period}`;
    //           points_TableElem1.innerHTML = 0;

    //       let totalPoints_TableElem1 = document.createElement('td');
    //           totalPoints_TableElem1.id = `total-points-${period}`;
    //           totalPoints_TableElem1.innerHTML = 0;

    //       let finalTokenBalance_TableElem1 = document.createElement('td');
    //           finalTokenBalance_TableElem1.id = `final-token-balance-${period}`;
    //           finalTokenBalance_TableElem1.innerHTML = tokenBalance_TableElem1.innerHTML

    //       currRow.appendChild(period_TableElem1);
    //       currRow.appendChild(income_TableElem1);
    //       currRow.appendChild(pricePerUnit_TableElem1);
    //       currRow.appendChild(inflation_TableElem1);
    //       currRow.appendChild(interestRate_TableElem1);
    //       currRow.appendChild(tokenBalance_TableElem1);
    //       currRow.appendChild(purchasedUnits_TableElem1);
    //       currRow.appendChild(points_TableElem1);
    //       currRow.appendChild(totalPoints_TableElem1);
    //       currRow.appendChild(finalTokenBalance_TableElem1);

    //       table.appendChild(currRow);

    //       let futureRow = document.createElement('tr');

    //       let period_TableElem2 = document.createElement('td');
    //       period_TableElem2.innerHTML = 2;

    //       let income_TableElem2 = document.createElement('td');
    //       income_TableElem2.innerHTML = calculatePlayerIncomeByPeriod(pay_sequence,income,period+1);

    //       let pricePerUnit_TableElem2 = pricePerUnit_TableElem1.cloneNode(true);
    //       let inflation_TableElem2 = inflation_TableElem1.cloneNode(true);
    //       let interestRate_TableElem2 = interestRate_TableElem1.cloneNode(true);

    //       let tokenBalance_TableElem2 = document.createElement('td');
    //           tokenBalance_TableElem2.id = `start-token-balance-${period+1}`
    //           //start with last period's token balance + interest on that balance
    //           tokenBalance_TableElem2.innerHTML = Number(tokenBalance_TableElem1.innerText)*(1+(Number(interest_rate)*.01));

    //       let purchasedUnits_TableElem2 = document.createElement('input');
    //           purchasedUnits_TableElem2.type = "number";
    //           purchasedUnits_TableElem2.min = 0;
    //           purchasedUnits_TableElem2.id = `purchased-unit-input-${period+1}`;
    //           purchasedUnits_TableElem2.style.cssText = "background-color:#ffbbff;text-align:center";

    //       let points_TableElem2 = document.createElement('td');
    //           points_TableElem2.id = `points-${period+1}`;
    //           points_TableElem2.innerHTML = 0;

    //       let totalPoints_TableElem2 = document.createElement('td');
    //           totalPoints_TableElem2.id = `total-points-${period+1}`;
    //           totalPoints_TableElem2.innerHTML = 0;

    //       let finalTokenBalance_TableElem2 = document.createElement('td');
    //           finalTokenBalance_TableElem2.id = `final-token-balance-${period+1}`;
    //           finalTokenBalance_TableElem2.innerHTML = tokenBalance_TableElem1.innerText;

    //       futureRow.appendChild(period_TableElem2);
    //       futureRow.appendChild(income_TableElem2);
    //       futureRow.appendChild(pricePerUnit_TableElem2);
    //       futureRow.appendChild(inflation_TableElem2);
    //       futureRow.appendChild(interestRate_TableElem2);
    //       futureRow.appendChild(tokenBalance_TableElem2);
    //       futureRow.appendChild(purchasedUnits_TableElem2);
    //       futureRow.appendChild(points_TableElem2);
    //       futureRow.appendChild(totalPoints_TableElem2);
    //       futureRow.appendChild(finalTokenBalance_TableElem2);

    //       table.appendChild(futureRow);
    //     }
    //   }

    </script>
  </div>
</div>