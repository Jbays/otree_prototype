{% load otree %}

<div class="card bg-light m-3">
  <div class="card-body">
    <h3>
        Calculator
    </h3>

    <style>
      table,
      td {
          border: 1px solid #333;
      }
      
      thead,
      tfoot {
          background-color: #333;
          color: #fff;
      }
    </style>

    <div style="display: none;">

      <div id="constants_income">
          {{Constants.income}}
        </div>
        <div id="constants_price_per_unit">
          {{Constants.price_per_unit}}
        </div>
        <div id="constants_interest_rate">
          {{Constants.interest_rate}}
        </div>
        <div id="constants_num_rounds">
          {{Constants.num_rounds}}
        </div>
        <div id="constants_k_payoff">
          {{Constants.k_payoff}}
        </div>

    </div>

    <table id="myTable" style="text-align: center;">
      <tbody id="table_body">
          <tr style="background-color:chartreuse;">
              <td>Period</td>
              <td>Income (Tokens)</td>
              <td>Price per Unit</td>
              <td>Interest Rate (%)</td>
              <td>Token Balance (beginning of the period)</td>
              <td>Purchased Units</td>
              <td>Points</td>
              <td>AccumulatedPoints</td>
              <td>Final Tokens Balance</td>
          </tr>
      </tbody>
    </table>

    <br/>
    <button onClick=resetValues(event)>Reset values</button>
    <button onClick=triggerRowUpdate(event)>Calculate</button>

    <script>
      //need a function called "gather all constants for later use"

      //resets values in the row (technically as a side effect)
      function resetValues(event,rowToErase=js_vars.player_round_number){
        let currentRow = document.getElementById(`row-period-${rowToErase}`);
        let allHypotheticals = document.getElementsByClassName('hypothetical');

        if ( allHypotheticals.length >= 1) {
          for ( let i = 0; i < 3; i++ ) {
            //i'm not sure why this works though...
            currentRow.removeChild(...allHypotheticals);
          }
        }

        console.log('values reset!');
      }

      //updates all rows in the future
      //triggered from clicking the Calculate button
      function updateTableFutures(period,numFromInput){
        console.log('now we update the rest of the table');
        console.log('period',period);

        let currTokenBalance = calculateTokenBalance(period).innerHTML || 0;
        let hypotheticalPointGainCellData = calculatePointsEarned(numFromInput,constantsKPayoff);
        let hypotheticalAccumulatedPoints = calculateAccumulatedPointsByPeriod(period,hypotheticalPointGainCellData.innerHTML);
        let hypotheticalFinalTokenBalance = calculateFinalTokenBalance(period,currTokenBalance,constantsPricePerUnit,numFromInput);
        
        hypotheticalPointGainCellData.className = 'hypothetical';
        hypotheticalAccumulatedPoints.className = 'hypothetical';
        hypotheticalFinalTokenBalance.className = 'hypothetical';

        // if ( currentRow.childElementCount === 6 ) {
        //   currentRow.appendChild(hypotheticalPointGainCellData);
        //   currentRow.appendChild(hypotheticalAccumulatedPoints);
        //   currentRow.appendChild(hypotheticalFinalTokenBalance);
        // } else {
        //   resetValues();
        //   //reappend the newly calculated values
        //   currentRow.appendChild(hypotheticalPointGainCellData);
        //   currentRow.appendChild(hypotheticalAccumulatedPoints);
        //   currentRow.appendChild(hypotheticalFinalTokenBalance);
        // }
        console.log('trying to update from tableFutures');
      }

      //updates the calculator's ui so user can cal
      function triggerRowUpdate(event,rowToUpdate=js_vars.player_round_number,mostRecentFinalTokenBalance=0){
        let inputData = document.getElementById(`purchased-unit-input-${rowToUpdate}`).value;
        console.log('inputData',inputData);
        console.log('rowToUpdate',rowToUpdate);
        console.log('js_vars.player_round_number',js_vars.player_round_number);
        console.log('mostRecentFinalTokenBalance',mostRecentFinalTokenBalance);

        let currentRow = document.getElementById(`row-period-${rowToUpdate}`);

        //if appending to the future, then update the token balance
        if ( rowToUpdate > js_vars.player_round_number ){
          let interestToBeAdded = mostRecentFinalTokenBalance*constantsInterestRate*.01;
          console.log('this is interest',interestToBeAdded);

          let tokenBalanceCell = document.getElementById(`token-balance-${rowToUpdate}`);
          //must add income too!
          tokenBalanceCell.innerHTML = interestToBeAdded+Number(constantsIncome)+Number(mostRecentFinalTokenBalance)
        };
        
        //if not passed a mostRecentFinalTokenBalance, then 
        // let currTokenBalance = calculateTokenBalance(rowToUpdate).innerHTML;
        
        let currTokenBalance = ( mostRecentFinalTokenBalance !== 0 ) ? mostRecentFinalTokenBalance+(mostRecentFinalTokenBalance*constantsInterestRate)
            : calculateTokenBalance(rowToUpdate).innerHTML;
        //     console.log('currTokenBalance',currTokenBalance);
        let hypotheticalPointGainCellData = calculatePointsEarned(inputData,constantsKPayoff);
        let hypotheticalAccumulatedPointsCellData = calculateAccumulatedPointsByPeriod(rowToUpdate,hypotheticalPointGainCellData.innerHTML);
        let hypotheticalFinalTokenBalanceCellData = calculateFinalTokenBalance(rowToUpdate,currTokenBalance,constantsPricePerUnit,inputData);
        
        hypotheticalPointGainCellData.className = 'hypothetical';
        hypotheticalAccumulatedPointsCellData.className = 'hypothetical';
        hypotheticalFinalTokenBalanceCellData.className = 'hypothetical';

        if ( currentRow.childElementCount === 6 ) {
          currentRow.appendChild(hypotheticalPointGainCellData);
          currentRow.appendChild(hypotheticalAccumulatedPointsCellData);
          currentRow.appendChild(hypotheticalFinalTokenBalanceCellData);
        } else {
          resetValues();
          //reappend the newly calculated values
          currentRow.appendChild(hypotheticalPointGainCellData);
          currentRow.appendChild(hypotheticalAccumulatedPointsCellData);
          currentRow.appendChild(hypotheticalFinalTokenBalanceCellData);
        }
        console.log('updated the calculator values!')

        // for ( let i = rowToUpdate+1; i <= constantsNumberOfRounds; i++ ) {
        for ( let i = rowToUpdate+1; i <= rowToUpdate+2; i++ ) {
          console.log('this is i',i);
          triggerRowUpdate(null,i,hypotheticalFinalTokenBalanceCellData.innerHTML);

          //should turn this into separate function -- can no longer think clearly about the logic
          //different depending on whether you're calculating on the present or a future period

        }

      }

      //calculates token balance
      //input is period and any calculated interest which is an integer and is simply added 
      function calculateTokenBalance(num,interest=0){
        let outputCellData = document.createElement('td');
        outputCellData.id = `token-balance-${num}`
        if ( num === 1 ) {
          outputCellData.innerHTML = constantsIncome
        } else {
          let tokenBalanceFromLastRound = document.getElementById(`final-token-balance-${num-1}`);
          
          if ( tokenBalanceFromLastRound ) {
            outputCellData.innerHTML = Number(tokenBalanceFromLastRound.innerHTML)+Number(constantsIncome)+interest;
          }
          
        }
        return outputCellData;
      }

      //calculates interest based on the period
      //finds the most recent final token balance,
      //calculates interested paid /owed
      //then returns that integer value
      function calculateInterestOnLastRoundsFinalTokenBalance(num){
        if ( num >= js_vars.player_round_number ) {
          console.log('num>>',num);
        }

        let tokenBalanceFromLastRound = document.getElementById(`final-token-balance-${num-1}`).innerHTML;

        return tokenBalanceFromLastRound*(constantsInterestRate*.01);
      }

      //
      function findPurchasedUnitsByPeriod(num,arr){
        let outputCellData = document.createElement('td');

        if ( arr[num-1] ){
          outputCellData.innerHTML = arr[num-1];
        }

        return outputCellData;
      }

      //calculate the points earned in a given round
      function calculatePointsEarned(unitsPurchased,constant){
        let outputCellData = document.createElement('td');
        outputCellData.innerHTML = (constant * ( unitsPurchased**0.5 )).toFixed(2);

        return outputCellData;
      }

      //calculate the total points earned up to that round
      function calculateAccumulatedPointsByPeriod(num,pointsJustEarned=0){
        if ( num >= js_vars.player_round_number ) {
          console.log('calculateAccumulatedPointsByPeriod this is num>>',num);
          console.log('calculateAccumulatedPointsByPeriod this is pointsJustEarned>>',pointsJustEarned);
        }
        let outputCellData = document.createElement('td');

        if ( num === 1 ) {
          outputCellData.innerText = pointsJustEarned;
        } else {
          let finalTokenBalanceFromLastRound = document.getElementById(`total-points-${num-1}`);
          console.log('finalTokenBalanceFromLastRound',finalTokenBalanceFromLastRound)
          outputCellData.innerHTML = (Number(finalTokenBalanceFromLastRound.innerHTML)+Number(pointsJustEarned)).toFixed(2);
        }

        return outputCellData
      }

      function calculateFinalTokenBalance(num,tokenBalance,pricePerUnit,unitsPurchased){
        let outputCellData = document.createElement('td');

        if ( num === 1 ) {
          outputCellData.innerHTML = Number(tokenBalance) - Number(pricePerUnit) * Number(unitsPurchased) ;
        } else {
          outputCellData.innerHTML = (Number(tokenBalance) - Number(pricePerUnit) * Number(unitsPurchased)).toFixed(2) ;
        }

        return outputCellData;
      }
      
      console.log(js_vars);
      let myTable = document.getElementById("myTable");

      //get a string (innerHTML) from a particular element, then remove all non-numerical values
      let constantsIncome = document.getElementById("constants_income").innerHTML.trim(); 
      let incomeCellData = document.createElement('td');
      incomeCellData.innerHTML = constantsIncome;

      let constantsPricePerUnit = document.getElementById("constants_price_per_unit").innerHTML.trim(); 
      let pricePerUnitCellData = document.createElement('td');
      pricePerUnitCellData.innerHTML = constantsPricePerUnit;

      let constantsInterestRate = document.getElementById("constants_interest_rate").innerHTML.trim(); 
      let interestRateCellData = document.createElement('td');
      interestRateCellData.innerHTML = constantsInterestRate;

      let constantsNumberOfRounds = document.getElementById("constants_num_rounds").innerHTML.trim()

      let constantsKPayoff = document.getElementById("constants_k_payoff").innerHTML.trim()

      //populate periods in the past
      for ( let i = 0; i < js_vars.player_round_number-1; i++ ) {
        let newRow = document.createElement('tr');
        newRow.style.cssText = "background-color:white"
        
        let period = i+1;
        let periodCellData = document.createElement('td');
        periodCellData.innerText = period;
        
        newRow.id = `row-period-${period}`

        let incomeClone = incomeCellData.cloneNode(true);
        let pricePerUnitClone = pricePerUnitCellData.cloneNode(true);
        let interestRateClone = interestRateCellData.cloneNode(true);
        
        let interestToBeAdded = (period > 1) ? calculateInterestOnLastRoundsFinalTokenBalance(period) : 0;
        
        let tokenBalanceCellData = calculateTokenBalance(period,interestToBeAdded);
        tokenBalanceCellData.id = `token-balance-${period}`

        let purchasedUnitsCellData = findPurchasedUnitsByPeriod(period,js_vars.purchased_units_across_all_rounds);
        purchasedUnitsCellData.id = `purchased-units-${period}`;

        let pointsEarnedCellData = calculatePointsEarned(purchasedUnitsCellData.innerHTML,constantsKPayoff);
        pointsEarnedCellData.id = `points-data-${period}`

        newRow.appendChild(periodCellData);
        newRow.appendChild(incomeClone);
        newRow.appendChild(pricePerUnitClone);
        newRow.appendChild(interestRateClone)

        //is this logic really necessary?
        if ( tokenBalanceCellData ) {
          newRow.appendChild(tokenBalanceCellData);
        }

        if ( purchasedUnitsCellData ) {
          newRow.appendChild(purchasedUnitsCellData);
        }

        let accumulatedPointsCellData = calculateAccumulatedPointsByPeriod(period,pointsEarnedCellData.innerHTML);
        accumulatedPointsCellData.id = `total-points-${period}`;

        let finalTokenBalanceCellData = 
          calculateFinalTokenBalance(period,tokenBalanceCellData.innerHTML,constantsPricePerUnit,purchasedUnitsCellData.innerHTML)
        finalTokenBalanceCellData.id = `final-token-balance-${period}`;

        newRow.appendChild(pointsEarnedCellData);
        newRow.appendChild(accumulatedPointsCellData);
        newRow.appendChild(finalTokenBalanceCellData);

        myTable.appendChild(newRow);
      };


      //populate current and future rounds
      for ( let i = js_vars.player_round_number-1; i < constantsNumberOfRounds; i++ ) {
        let newRow = document.createElement('tr');
        newRow.style.cssText = (i===js_vars.player_round_number-1) ? "background-color:yellow" : "background-color:#c6c6c6"

        let period = i+1;
        let periodCellData = document.createElement('td');
        periodCellData.innerText = period;

        newRow.id = `row-period-${period}`

        let incomeClone = incomeCellData.cloneNode(true);
        let pricePerUnitClone = pricePerUnitCellData.cloneNode(true);
        let interestRateClone = interestRateCellData.cloneNode(true);
        
        //only calculate interest for the preceeding round
        let interestToBeAdded = (i === js_vars.player_round_number-1) ? calculateInterestOnLastRoundsFinalTokenBalance(period) : 0;
        
        let tokenBalanceCellData = calculateTokenBalance(period,interestToBeAdded);

        let purchasedUnitsCellData = document.createElement('input');
        purchasedUnitsCellData.type = "number";
        purchasedUnitsCellData.min = 0;
        purchasedUnitsCellData.id = `purchased-unit-input-${period}`;
        purchasedUnitsCellData.style.cssText = "background-color:#ffbbff;text-align:center";

        newRow.appendChild(periodCellData);
        newRow.appendChild(incomeClone);
        newRow.appendChild(pricePerUnitClone);
        newRow.appendChild(interestRateClone);
        newRow.appendChild(tokenBalanceCellData);
        newRow.appendChild(purchasedUnitsCellData);

        //append token balance
        myTable.appendChild(newRow);
      }
    </script>

  </div>
</div>